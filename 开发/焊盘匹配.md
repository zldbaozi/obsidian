PadMatcher.h
```C++
#ifndef MT_GERBERPARSER_H_
#define MT_GERBERPARSER_H_

#include "GerberParserExport.h"
#include <QPointF>
#include <QRectF>
#include <QString>
#include <QList>
#include <QVector>

class GerberInfo;
class CGerberPadInfo;

namespace Vision
{
    enum GerberShapeType
    {
        GERB_SHAPE_LINE = 0,    ///<线段
        GERB_SHAPE_ARC,         ///<圆弧
        GERB_SHAPE_CIRCLE,      ///<圆
        GERB_SHAPE_ELLIPSE,     ///<椭圆
        GERB_SHAPE_RECTANGLE,   ///<矩形
        GERB_SHAPE_POLYGON,     ///<多边形
        GERB_SHAPE_AMACRO       ///<自定义
    };

    struct GerberShape
    {
        GerberShapeType type;   //形状类型

        double width;           //根据形状变化，线宽，矩形宽度
        double height;          //矩行宽度
        double angle1;          //圆弧起始角度
        double angle2;          //圆弧终点角度

        QVector<QPointF> points; //线段[0,1], 圆弧、圆、椭圆、矩形[0], 多边形所有点
        QString dcode;            //D码
        GerberShapeType stype;    //原始形状类型
        QVector<QPointF> spoints; //原始点
    };
    
    struct RectAngle
    {
        QPointF center;
        double width;
        double height;
        double angle;
    };

    struct GerberPad
    {
        QRectF           boundingBox;   //外接矩形
        RectAngle        rotateBox;     //旋转矩形
        double           area;          //面积
        QVector<QPointF> points;        //轮廓点
    };

    /**
     * @brief 解析gerber
     * @param[in,out] : path   gerber文件路径
     * @param[in,out] : shapes 返回解析的形状用于绘图
     * @return GBP_EXPORT
     */
    GBP_EXPORT int GerberParser(const QString& path, QList<GerberShape>& shapes);

    /**
     * @brief 提取焊盘
     * @param[in,out] : shapes 解析的形状
     * @param[in,out] : pads   返回合并的焊盘形状
     * @return GBP_EXPORT
     */
    GBP_EXPORT int ExtractShapes(const QList<GerberShape>& shapes, QList<GerberPad>& pads);

    // --- (新增) 相似焊盘匹配接口 ---
    /**
     * @brief 判断两个提取前焊盘(GerberInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target);

    /**
     * @brief 判断两个提取后焊盘(CGerberPadInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target);
}

#endif
```


PadMatcher.cpp
```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
    // --- 定义容差 ---
    static const double CMP_EPSILON = 0.0001;
    static const double AREA_EPSILON = 0.15;
    static const double DIST_EPSILON = 0.05;

    // --- 辅助函数 ---
    static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
    {
        return qAbs(a - b) < epsilon;
    }
    
	// 计算两点距离的平方（不开方，提高性能）
    static double DistSq(const QPointF& p1, const QPointF& p2)
    {
        double dx = p1.x() - p2.x();
        double dy = p1.y() - p2.y();
        return dx * dx + dy * dy;
    }


    bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
    {
        if (!tpl || !target) return false;

        const QVector<QPointF>& pts1 = tpl->GetPoint();
        const QVector<QPointF>& pts2 = target->GetPoint();

        // --- 核心：基于“旋转不变量”的几何特征比对 ---
        // 任何角度旋转，以下特征应当保持不变：
        // 1. 面积 (Area)
        // 2. 质心到轮廓点的最大距离 (Max Radius)
        // 3. 距离分布指纹 (Radius Variance/Sum)

        // 辅助 lambda：计算多边形面积和质心(重心)
        auto getAreaAndCenter = [](const QVector<QPointF>& pts, double& area, QPointF& center) {
            area = 0.0;
            double cx = 0.0, cy = 0.0;
            int n = pts.size();   //顶点数

            // 简单重心计算(顶点平均值)，对于凸多边形作为特征点足够稳定
            // 如果追求极致精确应使用多边形质心公式，但耗时更多
            if (n > 0) {
                for(const auto& p : pts) {
                    cx += p.x();
                    cy += p.y();
                }
                center = QPointF(cx / n, cy / n);
            }

            if(n < 3) { area=0; return; }
            for (int i = 0; i < n; ++i) {
                area += (pts[i].x() * pts[(i + 1) % n].y() - pts[(i + 1) % n].x() * pts[i].y());
            }
            area = qAbs(area) * 0.5;
        };

        // 辅助 lambda：计算旋转不变特征 (最大半径 & 半径平方和)
        auto getInvariantFeatures = [](const QVector<QPointF>& pts, const QPointF& center, double& maxR2, double& sumR2) {
            maxR2 = 0.0;
            sumR2 = 0.0;
            for (const auto& p : pts) {
                double dx = p.x() - center.x();
                double dy = p.y() - center.y();
                double d2 = dx*dx + dy*dy;
                if (d2 > maxR2) maxR2 = d2;
                sumR2 += d2;
            }
        };

        // --- 优先流程：基于点集的任意角度特征比对 ---
        if (!pts1.isEmpty() && !pts2.isEmpty())
        {
	        // 顶点数量检查，防止出现面积相同但不是同类的情况
            if (qAbs(pts1.size() - pts2.size()) > 5) return false;
            
            double area1, area2;
            QPointF c1, c2;

            getAreaAndCenter(pts1, area1, c1);
            getAreaAndCenter(pts2, area2, c2);

            // 1. 面积比对 (最基础筛选)
            if (qAbs(area1 - area2) > 0.1) return false;

            // 2. 几何指纹比对 (支持任意角度旋转)
            double maxR2_1, sumR2_1;
            double maxR2_2, sumR2_2;

            getInvariantFeatures(pts1, c1, maxR2_1, sumR2_1);
            getInvariantFeatures(pts2, c2, maxR2_2, sumR2_2);

            // 比较最大半径平方 (Max Radius Squared)
            if (qAbs(maxR2_1 - maxR2_2) > 0.3) return false;

            // 比较半径平方和 (Radius Squared Sum) - 类似于惯性矩的比对
            // 由于点数可能不同(尤其是圆/弧离散化后)，归一化处理比较好
            // 但如果 Gerber 生成方式一致，直接比较总和也是可行的
            // 这里为了稳健，如果点数差异巨大(比如差了一倍)，可能导致sum不同，
            // 建议先判定点数是否在一个数量级。

            // 为了解决不同拼版点数采样可能略有不同的问题，我们使用 "平均半径平方"
            double avgR2_1 = pts1.isEmpty() ? 0 : sumR2_1 / pts1.size();
            double avgR2_2 = pts2.isEmpty() ? 0 : sumR2_2 / pts2.size();

            // 容差可根据实际情况微调，一般 0.1 对于平方值来说已经很严了
            if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

            return true;
        }

        // --- 兜底流程：如果无法获取点数据 ---
        // 这一步仅针对极少数异常情况，通常不会走到这里
        if (tpl->GetShape() != target->GetShape()) return false;

        // 宽高等于0的(Region)如果没有点数据，无法判断，认为是同类(或不同类看策略)
        // 这里沿用旧逻辑，避免崩溃
        double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
        double w2 = target->GetWidth(); double h2 = target->GetHeight();

        // 对于有尺寸的标准图形，如果没点，退化回宽/高比较
        if (IsEqual(w1, 0.0) && IsEqual(h1, 0.0)) return true; // 盲目信任

        // 仅支持 0/90 度兜底，任意角度无法通过 WH 判断
        if (IsEqual(w1, w2) && IsEqual(h1, h2)) return true;
        if (IsEqual(w1, h2) && IsEqual(h1, w2)) return true;

        return false;
    }


    bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
    {
        if (!tpl || !target) return false;

        // 1. 面积快速筛选
        // [调整] 面积容差稍微放宽，防止特定旋转角度计算误差被剔除
        if (!IsEqual(tpl->GetArea(), target->GetArea(), 0.25)) return false;

        const auto& pts1 = tpl->GetRefPoint();
        const auto& pts2 = target->GetRefPoint();

        // 2. 点数筛选
        // [关键修改] 移除严格的点数相等判断 (pts1.size() != pts2.size())
        // 原因：任意角度旋转后，提取算法产生的多边形顶点数可能相差1-2个点。
        // 改为允许少许差异 (例如相差超过 5 个点才认为不同)
        if (qAbs(pts1.size() - pts2.size()) > 5) return false;

        if (pts1.isEmpty()) return true;

        // 3. 几何指纹特征 (旋转不变量)
        QPointF c1 = tpl->GetCenterPoint();
        double maxR2_1 = 0.0;
        double sumR2_1 = 0.0;
        for (const auto& p : pts1) {
            double d2 = DistSq(p, c1);
            if (d2 > maxR2_1) maxR2_1 = d2;
            sumR2_1 += d2;
        }

        QPointF c2 = target->GetCenterPoint();
        double maxR2_2 = 0.0;
        double sumR2_2 = 0.0;
        for (const auto& p : pts2) {
            double d2 = DistSq(p, c2);
            if (d2 > maxR2_2) maxR2_2 = d2;
            sumR2_2 += d2;
        }

        // (A) 比较最大半径平方
        // [调整] 放宽到 1.0 (对应约 0.5mm 的 R 偏差平方)，适应较大焊盘
        if (qAbs(maxR2_1 - maxR2_2) > 1.0) return false;

        // (B) 比较平均半径平方
        double avgR2_1 = sumR2_1 / pts1.size();
        double avgR2_2 = sumR2_2 / pts2.size();

        // [调整] 放宽到 0.5
        if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

        return true;
    }
}

```


在之前的实验中，不管我怎么调整代码，纯几何匹配始终绕不开面积，周长，重心以及重心到各个点的距离。但是焊盘中会出现较大的焊盘和较小的焊盘导致每次设置的误差难以覆盖所有焊盘，导致始终会出现误报或者漏报的情况。


为了解决“拼版误差导致的漏报”与“容差过大导致的误报”之间的矛盾，我们需要引入一种**自适应的分级判定策略 (Adaptive Hierarchical Check)**，而不是简单地全局放宽或收紧。

**核心思路：**

1. **面积 (Area)** 是最抗噪的特征。拼版带来的坐标漂移对面积积分的影响极小。如果面积差异超过一定范围（如 2.5%），直接判为不同。
2. **周长 (Perimeter)** 受噪声影响极大（锯齿效应），我们**大幅降低其权重**，仅作极粗的筛选。
3. **形状细节 (Sorted Radii)** 采用**动态容差**：
    - 如果**面积非常接近**（说明大概率是同一个东西），我们可以稍稍放宽对形状细节的要求，以容忍采样噪声。
    - 如果**面积处于边缘**（差异较大），我们必须严格要求形状细节一致，以防止是两个不同但大小相近的形状。

这种方法可以在保留对拼版数据（相同面积，轻微变形）兼容性的同时，剔除大小相近但形状不同（误报）的目标


```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"
#include "GerberParser/GerberParser.hh"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
// --- 定义容差 ---
static const double CMP_EPSILON = 0.0001;
// 尺寸容差：0.025mm (微调：兼顾拼版偏移和小焊盘精度)
static const double DIM_TOLERANCE = 0.025;
// 相对误差容差：3.0% (适度放宽：解决 Image1/3 漏报问题)
static const double RELATIVE_TOLERANCE = 0.03;

// --- 辅助函数 ---
static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
{
    return qAbs(a - b) < epsilon;
}

static bool IsSimilar(double a, double b, double epsilon = DIM_TOLERANCE)
{
    return qAbs(a - b) < epsilon;
}

static double DistSq(const QPointF& p1, const QPointF& p2)
{
    double dx = p1.x() - p2.x();
    double dy = p1.y() - p2.y();
    return dx * dx + dy * dy;
}

// --- 核心：基于轮廓点特征的严格比对 (支持任意角度) ---
static bool IsSamePolygon(const QVector<QPointF>& pts1, const QVector<QPointF>& pts2)
{
    // 0. 空检查
    if (pts1.isEmpty() || pts2.isEmpty()) return false;

    // 使用相对误差进行比较
    auto IsRelativeSimilar = [](double v1, double v2, double relTol, double absTol) -> bool {
        double diff = qAbs(v1 - v2);
        return diff < (qMax(v1, v2) * relTol + absTol);
    };

    // 1. 几何特征计算：精确重心(Centroid)、面积、周长
    auto calcGeoFeatures = [](const QVector<QPointF>& pts, double& outArea, double& outPerimeter, QPointF& outCenter) {
        int n = pts.size();
        outArea = 0.0;
        outPerimeter = 0.0;
        outCenter = QPointF(0,0);

        if (n == 0) return;
        if (n < 3) { // 点或线
            double cx=0, cy=0;
            for(auto& p : pts){ cx+=p.x(); cy+=p.y(); }
            outCenter = QPointF(cx/n, cy/n);
            return;
        }

        // 平移以提高精度
        double meanX = 0, meanY = 0;
        for(const auto& p : pts) { meanX += p.x(); meanY += p.y(); }
        QPointF origin = QPointF(meanX / n, meanY / n);

        double signedArea2 = 0.0;
        double cx_sum = 0.0;
        double cy_sum = 0.0;

        for (int i = 0; i < n; ++i) {
            double x0 = pts[i].x() - origin.x();
            double y0 = pts[i].y() - origin.y();
            double x1 = pts[(i + 1) % n].x() - origin.x();
            double y1 = pts[(i + 1) % n].y() - origin.y();

            double cross = x0 * y1 - x1 * y0;
            signedArea2 += cross;

            cx_sum += (x0 + x1) * cross;
            cy_sum += (y0 + y1) * cross;

            double dx = x0 - x1;
            double dy = y0 - y1;
            outPerimeter += sqrt(dx*dx + dy*dy);
        }

        outArea = qAbs(signedArea2) * 0.5;

        if (outArea < 1e-6) {
            outCenter = origin;
        } else {
            double factor = 1.0 / (3.0 * signedArea2);
            outCenter = QPointF(origin.x() + cx_sum * factor,
                                origin.y() + cy_sum * factor);
        }
    };

    double area1, peri1, area2, peri2;
    QPointF c1, c2;
    calcGeoFeatures(pts1, area1, peri1, c1);
    calcGeoFeatures(pts2, area2, peri2, c2);

    // 2. 面积比对 (3.0%) - 放宽至3%以接纳 Image1/3 的拼版变形
    double maxArea = qMax(area1, area2);
    double areaDiff = qAbs(area1 - area2);
    double areaErrRatio = (maxArea > 1e-9) ? (areaDiff / maxArea) : 0.0;

    if (areaErrRatio > 0.03 && areaDiff > 0.03) return false;

    // 3. 周长比对 (保持10%)
    if (!IsRelativeSimilar(peri1, peri2, 0.10, 0.10)) {
        int n1 = pts1.size();
        int n2 = pts2.size();
        if (qAbs(n1 - n2) < 5) return false;
    }

    // 4. 计算半径特征
    // Fix: 剔除 Gerber Polygon 可能存在的闭合重复点 (例如 A,B,C,D,A),
        // 否则旋转会导致不同顶点的重复计数，破坏 Sort 后的半径对齐检查。
    QVector<double> r1, r2;

    auto fillRadii = [](const QVector<QPointF>& pts, const QPointF& center, QVector<double>& outR) {
        if (pts.isEmpty()) return;
        int limit = pts.size();
        // 如果收尾点重合，忽略最后一个点
        if (limit > 1 && DistSq(pts.first(), pts.last()) < 1e-6) {
            limit--;
        }
        outR.reserve(limit);
        for (int i = 0; i < limit; ++i) {
            outR.append(DistSq(pts[i], center));
        }
    };

    fillRadii(pts1, c1, r1);
    fillRadii(pts2, c2, r2);

    std::sort(r1.begin(), r1.end());
    std::sort(r2.begin(), r2.end());

    // 5. 动态阈值的半径分布比对
    // 关键调整：引入 Min/Max 严格边界，防止面积相同时对形状误判 (针对用户反馈的 Pasted Image 问题)
    // 同时保持中间分布的中等容差，以兼容拼版噪声

    double allowedRadiusErr = 0.02;

    if (areaErrRatio < 0.015) {
        // 高置信度 (面积差异 < 1.5%)
        // 之前放宽到 4.5% 导致了不同形状的误报。现在收紧至 3.5%，并依靠 Min/Max 检查兜底。
        allowedRadiusErr = 0.035;
    } else {
        // 低置信度 -> 保持严格 2.5%
        allowedRadiusErr = 0.025;
    }

    int n1 = r1.size();
    int n2 = r2.size();

    if (n1 == n2) {
        double maxR21 = r1.last();
        double maxR22 = r2.last();
        double maxR2 = qMax(maxR21, maxR22);

        if (maxR2 < 1e-9) return true;

        // [核心防线 1] Min Radius Check
        // 用于区分面积相同但结构不同的形状 (如：子弹头 vs 跑道圆)
        // 它们的几何重心到最近边的距离通常差异很大。
        // 设定严格阈值：3.5% (平方域)
        double minR21 = r1.first();
        double minR22 = r2.first();
        if (qAbs(minR21 - minR22) > (qMax(minR21, minR22) * 0.035 + 0.002)) return false;

        // [核心防线 2] Max Radius Check (对角线长度)
        // 设定严格阈值：3.0% (平方域)
        if (qAbs(maxR21 - maxR22) > (maxR2 * 0.03 + 0.002)) return false;

        // [整体分布检查]
        double totalDiff = 0.0;
        for (int i = 0; i < n1; ++i) {
            totalDiff += qAbs(r1[i] - r2[i]);
        }
        double avgDiff = totalDiff / n1;

        // 使用动态阈值 + 低底噪 (0.002)
        if (avgDiff > (maxR2 * allowedRadiusErr + 0.002)) return false;

    } else {
        // 点数不同
        double maxR2_1 = r1.last();
        double maxR2_2 = r2.last();

        // 严查 Max Radius
        if (!IsRelativeSimilar(maxR2_1, maxR2_2, 0.03, 0.002)) return false;

        // 严查 Min Radius
        double minR2_1 = r1.first();
        double minR2_2 = r2.first();
        if (!IsRelativeSimilar(minR2_1, minR2_2, 0.035, 0.002)) return false;

        double sum1 = 0; for(double v:r1) sum1+=sqrt(v);
        double sum2 = 0; for(double v:r2) sum2+=sqrt(v);
        double avg1 = sum1/n1;
        double avg2 = sum2/n2;

        if (!IsRelativeSimilar(avg1, avg2, allowedRadiusErr, 0.02)) return false;
    }

    return true;
}



bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
{
    if (!tpl || !target) return false;

    // 形状大类检查
    // 注意：有些CAM软件会在镜像/旋转后将标准形状(Rect)转为Polgyon
    // 如果我们要支持跨类型匹配（Reg <-> Poly），需要更复杂的逻辑。
    //这里暂时保留严格类型检查，如遇到Rect匹配Poly的情况需在外部处理或Relax此检查
    if (tpl->GetShape() != target->GetShape()) return false;

    int shapeType = tpl->GetShape();
    bool isRegularShape = (shapeType != GERB_SHAPE_POLYGON && shapeType != GERB_SHAPE_AMACRO);

    if (isRegularShape)
    {
        // === 正常标准形状 (Rect, Circle, etc) ===
        // 对于标准形状，支持任意角度旋转的最简单方法是：比较排序后的长宽
        // 只要短边等于短边，长边等于长边，那就是同一个形状（无论怎么转）

        double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
        double w2 = target->GetWidth(); double h2 = target->GetHeight();

        // 排除 0,0 的无效数据情况
        if (IsEqual(w1,0) && IsEqual(h1,0)) return false;

        double min1 = qMin(w1, h1); double max1 = qMax(w1, h1);
        double min2 = qMin(w2, h2); double max2 = qMax(w2, h2);

        // 使用 IsSimilar (0.05mm) 而不是 IsEqual (0.0001mm)
        if (!IsSimilar(min1, min2)) return false;
        if (!IsSimilar(max1, max2)) return false;

        return true;
    }
    else
    {
        // === 异形焊盘 (Polygon) ===
        const QVector<QPointF>& pts1 = tpl->GetPoint();
        const QVector<QPointF>& pts2 = target->GetPoint();
        return IsSamePolygon(pts1, pts2);
    }
}



bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
{
    if (!tpl || !target) return false;

    // 初步面积筛查
    double a1 = tpl->GetArea();
    double a2 = target->GetArea();
    // 相对误差检查 (调至 3.0%，接纳拼版变形)
    if (qAbs(a1 - a2) > (qMax(a1,a2) * 0.03 + 0.01)) return false;

    const auto& pts1 = tpl->GetRefPoint();
    const auto& pts2 = target->GetRefPoint();

    // 简单焊盘 (无轮廓点)
    if (pts1.isEmpty() && pts2.isEmpty())
    {
        // 修改：使用包围盒获取宽高
        // 假设接口为 GetBoundingBox() 返回 QRectF (根据 GerberPad 定义推断)
        QRectF box1 = tpl->GetBoundingBox();
        QRectF box2 = target->GetBoundingBox();

        double w1 = box1.width();
        double h1 = box1.height();
        double w2 = box2.width();
        double h2 = box2.height();

        // 放宽容差：使用 IsSimilar (0.05mm)
        // 严格尺寸匹配
        if (IsSimilar(w1, w2) && IsSimilar(h1, h2)) return true;
        // 90度旋转匹配
        if (IsSimilar(w1, h2) && IsSimilar(h1, w2)) return true;

        return false;
    }

    // 结构不一致 (一个有轮廓，一个没有)
    if (pts1.isEmpty() != pts2.isEmpty()) return false;

    // 异形焊盘：使用严格几何比对
    // (周长、计算包围盒)
    return IsSamePolygon(pts1, pts2);
}
}



```


我将针对“圆弧类焊盘”的匹配失效问题进行深度优化。目前的算法主要依赖重心到顶点的半径分布，这虽然对旋转不敏感，但对于“圆弧段”或“离散点组成的圆周”非常不稳定，因为离散化程度（点数）和重心微小偏移都会导致分布曲线剧烈波动，从而产生误匹配（如你提到的黄圈处）或漏匹配。

我计划引入**形状紧凑度（Compactness）**、**矩形度（Rectangularity）**和**特征半径分析**，这些特征对于区分圆弧、多点圆和异形块非常有效。

### 主要改动说明：

1. **引入重采样比对（Resampling）**：
    
    - 针对圆弧和异形焊盘，传统逐点比对极易因采样点数不同（例如一个圆弧 10 个点，另一个 50 个点）而失效。
    - 新算法将所有多边形统一重采样为 **64 个等距点**，再进行中心距分布比对，显著提升了圆弧同类识别的精度和鲁棒性。
2. **增加圆度（Circularity）约束**：
    
    - 计算 4πArea/Perimeter24πArea/Perimeter2。圆形的圆度接近 1，而线段组合或狭长弧线的圆度较低。
    - 这一特征能有效区分 Image 2 中黄圈处（线段组合）与你框选的真实弧线（圆度完全不同）。
3. **修复周长过滤逻辑**：
    
    - 修正了原代码中“周长不等但只要点数差异大就放过”的逻辑漏洞。现在周长偏差超过 10% 会被直接剔除。

4. **重心与半径分布优化**：
    
    - 加入了点集去重（CleanPoints），防止 Gerber 导出时首尾重复点干扰重心计算。
    - 使用了动态半径容差，根据面积接近程度自动调整判定严苛度。


```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"
#include "GerberParser/GerberParser.hh"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
// --- 定义容差 ---
static const double CMP_EPSILON = 0.0001;
// 尺寸容差：0.025mm (微调：兼顾拼版偏移和小焊盘精度)
static const double DIM_TOLERANCE = 0.025;
// 相对误差容差：3.0% (适度放宽：解决 Image1/3 漏报问题)
static const double RELATIVE_TOLERANCE = 0.03;

// --- 辅助函数 ---
static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
{
    return qAbs(a - b) < epsilon;
}

static bool IsSimilar(double a, double b, double epsilon = DIM_TOLERANCE)
{
    return qAbs(a - b) < epsilon;
}

static double DistSq(const QPointF& p1, const QPointF& p2)
{
    double dx = p1.x() - p2.x();
    double dy = p1.y() - p2.y();
    return dx * dx + dy * dy;
}

// --- 核心：基于轮廓点特征的严格比对 (针对圆弧、线段组合优化) ---
static bool IsSamePolygon(const QVector<QPointF>& inPts1, const QVector<QPointF>& inPts2)
{
    // 0. 空检查
    if (inPts1.isEmpty() || inPts2.isEmpty()) return false;

    // --- 预处理：去重 ---
    auto CleanPoints = [](const QVector<QPointF>& pts) -> QVector<QPointF> {
        if (pts.size() < 2) return pts;
        QVector<QPointF> out;
        out.reserve(pts.size());
        out.append(pts[0]);
        for(int i = 1; i < pts.size(); ++i) {
            if (DistSq(pts[i], out.last()) > 1e-9) out.append(pts[i]);
        }
        if (out.size() > 2 && DistSq(out.first(), out.last()) < 1e-9) out.pop_back();
        return out;
    };

    const QVector<QPointF> pts1 = CleanPoints(inPts1);
    const QVector<QPointF> pts2 = CleanPoints(inPts2);

    // 使用相对误差进行比较
    auto IsRelativeSimilar = [](double v1, double v2, double relTol, double absTol) -> bool {
        double diff = qAbs(v1 - v2);
        return diff < (qMax(v1, v2) * relTol + absTol);
    };

    // 1. 几何特征计算：精确重心(Centroid)、面积、周长
    auto calcGeoFeatures = [](const QVector<QPointF>& pts, double& outArea, double& outPerimeter, QPointF& outCenter) {
        int n = pts.size();
        outArea = 0.0;
        outPerimeter = 0.0;
        outCenter = QPointF(0,0);

        if (n == 0) return;
        if (n < 3) { // 点或线
            double cx=0, cy=0;
            for(auto& p : pts){ cx+=p.x(); cy+=p.y(); }
            outCenter = QPointF(cx/n, cy/n);
            return;
        }

        double meanX = 0, meanY = 0;
        for(const auto& p : pts) { meanX += p.x(); meanY += p.y(); }
        QPointF origin = QPointF(meanX / n, meanY / n);

        double signedArea2 = 0.0;
        double cx_sum = 0.0;
        double cy_sum = 0.0;


        for (int i = 0; i < n; ++i) {
            double x0 = pts[i].x() - origin.x();
            double y0 = pts[i].y() - origin.y();
            double x1 = pts[(i + 1) % n].x() - origin.x();
            double y1 = pts[(i + 1) % n].y() - origin.y();
            double cross = x0 * y1 - x1 * y0;
            signedArea2 += cross;
            cx_sum += (x0 + x1) * cross;
            cy_sum += (y0 + y1) * cross;
            double dx = x1 - x0, dy = y1 - y0;
            outPerimeter += sqrt(dx*dx + dy*dy);
        }

        outArea = qAbs(signedArea2) * 0.5;
        if (outArea < 1e-6) outCenter = origin;
        else {
            double factor = 1.0 / (3.0 * signedArea2);
            outCenter = QPointF(origin.x() + cx_sum * factor, origin.y() + cy_sum * factor);
        }
    };

    double area1, peri1, area2, peri2;
    QPointF c1, c2;
    calcGeoFeatures(pts1, area1, peri1, c1);
    calcGeoFeatures(pts2, area2, peri2, c2);

    // 2. 核心过滤：面积 (3.0%) 与 周长 (10%)
    // 周长若不匹配，则直接返回 false
    double maxArea = qMax(area1, area2);
    if (qAbs(area1 - area2) > (maxArea * 0.03 + 0.01)) return false;
    if (!IsRelativeSimilar(peri1, peri2, 0.10, 0.10)) return false;

    // 3. 形状描述符：圆度 (Circularity) - 圆: ≈1, 异形/线段组合: 偏低
    auto calcCirc = [](double a, double p) { return (p > 1e-6) ? (4.0 * 3.14159265 * a / (p * p)) : 0.0; };
    if (qAbs(calcCirc(area1, peri1) - calcCirc(area2, peri2)) > 0.10) return false;

    // 4. 计算半径分布并重采样 (解决采样密度不同导致圆弧匹配失效的问题)
    auto getSortedRadii = [](const QVector<QPointF>& pts, const QPointF& center) {
        QVector<double> r;
        r.reserve(pts.size());
        for (const auto& p : pts) r.append(DistSq(p, center));
        std::sort(r.begin(), r.end());
        return r;
    };

    QVector<double> r1_raw = getSortedRadii(pts1, c1);
    QVector<double> r2_raw = getSortedRadii(pts2, c2);

    // 使用 64 点重采样对比分布，确保圆弧识别具有旋转和采样鲁棒性
    auto resampleRadii = [](const QVector<double>& src, int targetCount) {
        QVector<double> dst;
        if (src.isEmpty()) return dst;
        dst.reserve(targetCount);
        int n = src.size();
        for (int i = 0; i < targetCount; ++i) {
            double pos = (double)i * (n - 1) / (double)(targetCount - 1);
            int idx = (int)pos;
            double fract = pos - idx;
            if (idx + 1 < n) dst.append(src[idx] * (1.0 - fract) + src[idx+1] * fract);
            else dst.append(src[idx]);
        }
        return dst;
    };

    const int SAMPLES = 64;
    QVector<double> r1 = resampleRadii(r1_raw, SAMPLES);
    QVector<double> r2 = resampleRadii(r2_raw, SAMPLES);

    // 5. 分布精细比对
    double maxR2 = qMax(r1.last(), r2.last());
    if (maxR2 < 1e-9) return true;

    // [边界检查]
    if (qAbs(r1.first() - r2.first()) > (maxR2 * 0.05 + 0.002)) return false;
    if (qAbs(r1.last() - r2.last()) > (maxR2 * 0.04 + 0.002)) return false;

    // [整体分布比对]
    double totalDiff = 0.0;
    for (int i = 0; i < SAMPLES; ++i) totalDiff += qAbs(r1[i] - r2[i]);
    double avgDiff = totalDiff / SAMPLES;

    double allowedRadiusErr = (qAbs(area1 - area2) / maxArea < 0.015) ? 0.035 : 0.025;
    if (avgDiff > (maxR2 * allowedRadiusErr + 0.002)) return false;

    return true;
}




bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
{
    if (!tpl || !target) return false;

    // 严格形状大类匹配。圆弧/标准圆/矩形等标准形状不参与异形焊盘匹配。
    if (tpl->GetShape() != target->GetShape()) return false;

    int shapeType = tpl->GetShape();
    bool isRegularShape = (shapeType != GERB_SHAPE_POLYGON && shapeType != GERB_SHAPE_AMACRO);

    if (isRegularShape)
    {
        // === 标准形状 (Rect, Circle, Arc, etc) ===
        double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
        double w2 = target->GetWidth(); double h2 = target->GetHeight();

        if (IsEqual(w1,0) && IsEqual(h1,0)) return false;

        // 比较排序后的长宽，支持 90/180/270 度旋转匹配
        double min1 = qMin(w1, h1); double max1 = qMax(w1, h1);
        double min2 = qMin(w2, h2); double max2 = qMax(w2, h2);

        if (!IsSimilar(min1, min2)) return false;
        if (!IsSimilar(max1, max2)) return false;

        return true;
    }
    else
    {
        // === 异形焊盘 (Polygon/Aperture Macro) ===
        const QVector<QPointF>& pts1 = tpl->GetPoint();
        const QVector<QPointF>& pts2 = target->GetPoint();

        // 如果点集为空，视为无效匹配
        if (pts1.isEmpty() || pts2.isEmpty()) return false;

        return IsSamePolygon(pts1, pts2);
    }
}



bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
{
    if (!tpl || !target) return false;

    // 初步面积筛查
    double a1 = tpl->GetArea();
    double a2 = target->GetArea();
    // 相对误差检查 (调至 3.0%，接纳拼版变形)
    if (qAbs(a1 - a2) > (qMax(a1,a2) * 0.03 + 0.01)) return false;

    const auto& pts1 = tpl->GetRefPoint();
    const auto& pts2 = target->GetRefPoint();

    // 简单焊盘 (无轮廓点)
    if (pts1.isEmpty() && pts2.isEmpty())
    {
        // 使用包围盒获取宽高
        // 假设接口为 GetBoundingBox() 返回 QRectF (根据 GerberPad 定义推断)
        QRectF box1 = tpl->GetBoundingBox();
        QRectF box2 = target->GetBoundingBox();

        double w1 = box1.width();
        double h1 = box1.height();
        double w2 = box2.width();
        double h2 = box2.height();

        // 放宽容差：使用 IsSimilar (0.05mm)
        // 严格尺寸匹配
        if (IsSimilar(w1, w2) && IsSimilar(h1, h2)) return true;
        // 90度旋转匹配
        if (IsSimilar(w1, h2) && IsSimilar(h1, w2)) return true;

        return false;
    }

    // 结构不一致 (一个有轮廓，一个没有)
    if (pts1.isEmpty() != pts2.isEmpty()) return false;

    // 异形焊盘：使用严格几何比对
    // (周长、计算包围盒)
    return IsSamePolygon(pts1, pts2);
}
}

```


### 验证建议：

EditWidget.cpp
```C++
void EditWidget::on_toolButton_similarPads_clicked()
{
    // 1. 获取场景
    if (!ui->widget_view || !ui->widget_view->GetImageView()) return;
    QGraphicsScene* pScene = ui->widget_view->GetImageView()->Scene();
    if (!pScene) return;

    // 2. 获取当前选中的 Items (作为模板)
    QList<QGraphicsItem*> selectedItems = ui->widget_view->GetImageView()->GetSelectedItems();
    if (selectedItems.isEmpty()) {
        LOG_INFO("not choose any pad as template");
        return;
    }

    // [修改说明]
    // 移除基于 DCode 的快速筛选逻辑 (templateDCodes)。
    // 之前的逻辑会导致：如果模板有D码，它只会被记录D码，而不会进入几何特征列表。
    // 这会导致 "同形状但不同D码" 的焊盘无法匹配 (因为几何列表为空)。
    // 现在我们将所有选中的焊盘都有作为几何模板，调用 IsSameGerberInfo 进行统一的 robust 匹配。

    QList<GerberInfo*> preTemplatesGeom;
    QList<CGerberPadInfo*> postTemplates;

    for (QGraphicsItem* item : selectedItems)
    {
        // 类型转换：PadItem (提取前)
        PadItem* pItem = dynamic_cast<PadItem*>(item);
        if (pItem && pItem->getGerberInfo()) {
            GerberInfo* info = pItem->getGerberInfo();
            // 不再区分是否有 DCode，全部加入几何匹配流程
            preTemplatesGeom.append(info);
            continue;
        }

        // 类型转换：CGerberPadItem (提取后)
        CGerberPadItem* cpItem = dynamic_cast<CGerberPadItem*>(item);
        if (cpItem) {
            postTemplates.append(cpItem->getGerberInfo());
            continue;
        }
    }

    QString logMsg = QString("Templates: Gerber(Pre)=%0, Extracted(Post)=%1")
                         .arg(preTemplatesGeom.count()).arg(postTemplates.count());
    LOG_INFO(logMsg.toUtf8().constData());

    if (preTemplatesGeom.isEmpty() && postTemplates.isEmpty()) return;

    // 3. 遍历全场进行匹配
    bool wasBlocked = pScene->blockSignals(true); // 提升性能
    QList<QGraphicsItem*> allItems = pScene->items();
    int newCount = 0;

    for (QGraphicsItem* item : allItems)
    {
        if (item->isSelected()) continue;

        bool isMatch = false;

        // --- 匹配 PadItem (提取前) ---
        PadItem* target = dynamic_cast<PadItem*>(item);
        if (target && target->getGerberInfo()) {
            GerberInfo* tInfo = target->getGerberInfo();

            // 使用统一的几何特征匹配
            // 不再使用 DCode shortcut，确保不同 DCode 但形状相同的焊盘能被匹配
            for (GerberInfo* tpl : preTemplatesGeom) {
                if (Vision::IsSameGerberInfo(tpl, tInfo))
                {
                    isMatch = true;
                    break;
                }
            }
        }

        // 匹配 CGerberPadItem (提取后)
        if (!isMatch && !postTemplates.isEmpty()) {
            CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item);
            if (extractTarget && extractTarget->getGerberInfo()) {
                CGerberPadInfo* tInfo = extractTarget->getGerberInfo();
                for (CGerberPadInfo* tpl : postTemplates) {
                    if (Vision::IsSameCGerberPadInfo(tpl, tInfo)) {
                        isMatch = true;
                        break;
                    }
                }
            }
        }

        if (isMatch) {
            // 设置选中状态
            if (target) {
                target->SetSelectState(true);
            } else if (CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item)) {
                extractTarget->SetSelectState(true);
            }
            newCount++;
        }
    }

    pScene->blockSignals(wasBlocked);

    // 4. 刷新界面
    if (newCount > 0)
    {
        // 重新统计，确保 View 和 Model 数量一致
        QList<QGraphicsItem*> finalSelected = ui->widget_view->GetImageView()->GetSelectedItems();
        emit ui->widget_view->GetImageView()->signalSelectNum(finalSelected.count());
        ui->widget_view->GetImageView()->viewport()->update();
        LOG_INFO(QString("Matched %0 similar pads.").arg(newCount).toLocal8Bit());
    }
}

}```



ImageView.cpp
```C++
QList<QGraphicsItem*> ImageView::GetSelectedItems()
{
    QList<QGraphicsItem*> list;  //创建空列表来存储选中的item

    // 获取图层列表 
    QMap<QString, QGraphicsItemGroup *> groups = GetImageLayers(); //GetImageLayers()返回一个映射（QMap）,其中键（key）是图层的名称（QString），值（value）是当前图层中所选中的item。

    for (auto it = groups.begin(); it != groups.end(); ++it)  //遍历每一个图层
    {
        QGraphicsItemGroup* group = it.value();  //当前图层所有选中的item

        if (!group || !group->isVisible())   //当前图层是否有效且可见
            continue;
            
        LayerType type = group->data(Qt::UserRole + 1).value<LayerType>();  //从每一份图层中获取类型；在QT中使用data方法为对象存储自定义数据，这里使用Qt::UserRole + 1作为键来获取存储的数据，并将其转换为LayerType枚举类型（CAD，GERBER——PAD，GERBER）
        for (QGraphicsItem* item : group->childItems())   //遍历图层的每个选中的item
        {
            bool isSelected = false;

            if (type == LayerType::CAD)
            {
                CrossItem* crossItem = dynamic_cast<CrossItem*>(item); //如果选中的item是CAD，就将图形item转换为CrossItem，这里使用的是dynamic_cast（安全地向下转型），它是C++中的一个类型转换操作符，主要用于多态类型之间的转换，将基类指针或引用转换为派生类指针或引用，这是dynamic_cast最常见的用途。
                if (crossItem && crossItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER_PAD)
            {
                CGerberPadItem* padItem = dynamic_cast<CGerberPadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER)
            {
                PadItem* padItem = dynamic_cast<PadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }

            if (isSelected)
            {
                list.append(item);   //如果图形被选中，就添加到列表
            }
        }
    }
    return list;
}
```