PadMatcher.h
```C++
#ifndef MT_GERBERPARSER_H_
#define MT_GERBERPARSER_H_

#include "GerberParserExport.h"
#include <QPointF>
#include <QRectF>
#include <QString>
#include <QList>
#include <QVector>

class GerberInfo;
class CGerberPadInfo;

namespace Vision
{
    enum GerberShapeType
    {
        GERB_SHAPE_LINE = 0,    ///<线段
        GERB_SHAPE_ARC,         ///<圆弧
        GERB_SHAPE_CIRCLE,      ///<圆
        GERB_SHAPE_ELLIPSE,     ///<椭圆
        GERB_SHAPE_RECTANGLE,   ///<矩形
        GERB_SHAPE_POLYGON,     ///<多边形
        GERB_SHAPE_AMACRO       ///<自定义
    };

    struct GerberShape
    {
        GerberShapeType type;   //形状类型

        double width;           //根据形状变化，线宽，矩形宽度
        double height;          //矩行宽度
        double angle1;          //圆弧起始角度
        double angle2;          //圆弧终点角度

        QVector<QPointF> points; //线段[0,1], 圆弧、圆、椭圆、矩形[0], 多边形所有点
        QString dcode;            //D码
        GerberShapeType stype;    //原始形状类型
        QVector<QPointF> spoints; //原始点
    };
    
    struct RectAngle
    {
        QPointF center;
        double width;
        double height;
        double angle;
    };

    struct GerberPad
    {
        QRectF           boundingBox;   //外接矩形
        RectAngle        rotateBox;     //旋转矩形
        double           area;          //面积
        QVector<QPointF> points;        //轮廓点
    };

    /**
     * @brief 解析gerber
     * @param[in,out] : path   gerber文件路径
     * @param[in,out] : shapes 返回解析的形状用于绘图
     * @return GBP_EXPORT
     */
    GBP_EXPORT int GerberParser(const QString& path, QList<GerberShape>& shapes);

    /**
     * @brief 提取焊盘
     * @param[in,out] : shapes 解析的形状
     * @param[in,out] : pads   返回合并的焊盘形状
     * @return GBP_EXPORT
     */
    GBP_EXPORT int ExtractShapes(const QList<GerberShape>& shapes, QList<GerberPad>& pads);

    // --- (新增) 相似焊盘匹配接口 ---
    /**
     * @brief 判断两个提取前焊盘(GerberInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target);

    /**
     * @brief 判断两个提取后焊盘(CGerberPadInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target);
}

#endif
```


PadMatcher.cpp
```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
    // --- 定义容差 ---
    static const double CMP_EPSILON = 0.0001;
    static const double AREA_EPSILON = 0.15;
    static const double DIST_EPSILON = 0.05;

    // --- 辅助函数 ---
    static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
    {
        return qAbs(a - b) < epsilon;
    }
    
	// 计算两点距离的平方（不开方，提高性能）
    static double DistSq(const QPointF& p1, const QPointF& p2)
    {
        double dx = p1.x() - p2.x();
        double dy = p1.y() - p2.y();
        return dx * dx + dy * dy;
    }


    bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
    {
        if (!tpl || !target) return false;

        const QVector<QPointF>& pts1 = tpl->GetPoint();
        const QVector<QPointF>& pts2 = target->GetPoint();

        // --- 核心：基于“旋转不变量”的几何特征比对 ---
        // 任何角度旋转，以下特征应当保持不变：
        // 1. 面积 (Area)
        // 2. 质心到轮廓点的最大距离 (Max Radius)
        // 3. 距离分布指纹 (Radius Variance/Sum)

        // 辅助 lambda：计算多边形面积和质心(重心)
        auto getAreaAndCenter = [](const QVector<QPointF>& pts, double& area, QPointF& center) {
            area = 0.0;
            double cx = 0.0, cy = 0.0;
            int n = pts.size();   //顶点数

            // 简单重心计算(顶点平均值)，对于凸多边形作为特征点足够稳定
            // 如果追求极致精确应使用多边形质心公式，但耗时更多
            if (n > 0) {
                for(const auto& p : pts) {
                    cx += p.x();
                    cy += p.y();
                }
                center = QPointF(cx / n, cy / n);
            }

            if(n < 3) { area=0; return; }
            for (int i = 0; i < n; ++i) {
                area += (pts[i].x() * pts[(i + 1) % n].y() - pts[(i + 1) % n].x() * pts[i].y());
            }
            area = qAbs(area) * 0.5;
        };

        // 辅助 lambda：计算旋转不变特征 (最大半径 & 半径平方和)
        auto getInvariantFeatures = [](const QVector<QPointF>& pts, const QPointF& center, double& maxR2, double& sumR2) {
            maxR2 = 0.0;
            sumR2 = 0.0;
            for (const auto& p : pts) {
                double dx = p.x() - center.x();
                double dy = p.y() - center.y();
                double d2 = dx*dx + dy*dy;
                if (d2 > maxR2) maxR2 = d2;
                sumR2 += d2;
            }
        };

        // --- 优先流程：基于点集的任意角度特征比对 ---
        if (!pts1.isEmpty() && !pts2.isEmpty())
        {
	        // 顶点数量检查，防止出现面积相同但不是同类的情况
            if (qAbs(pts1.size() - pts2.size()) > 5) return false;
            
            double area1, area2;
            QPointF c1, c2;

            getAreaAndCenter(pts1, area1, c1);
            getAreaAndCenter(pts2, area2, c2);

            // 1. 面积比对 (最基础筛选)
            if (qAbs(area1 - area2) > 0.1) return false;

            // 2. 几何指纹比对 (支持任意角度旋转)
            double maxR2_1, sumR2_1;
            double maxR2_2, sumR2_2;

            getInvariantFeatures(pts1, c1, maxR2_1, sumR2_1);
            getInvariantFeatures(pts2, c2, maxR2_2, sumR2_2);

            // 比较最大半径平方 (Max Radius Squared)
            if (qAbs(maxR2_1 - maxR2_2) > 0.3) return false;

            // 比较半径平方和 (Radius Squared Sum) - 类似于惯性矩的比对
            // 由于点数可能不同(尤其是圆/弧离散化后)，归一化处理比较好
            // 但如果 Gerber 生成方式一致，直接比较总和也是可行的
            // 这里为了稳健，如果点数差异巨大(比如差了一倍)，可能导致sum不同，
            // 建议先判定点数是否在一个数量级。

            // 为了解决不同拼版点数采样可能略有不同的问题，我们使用 "平均半径平方"
            double avgR2_1 = pts1.isEmpty() ? 0 : sumR2_1 / pts1.size();
            double avgR2_2 = pts2.isEmpty() ? 0 : sumR2_2 / pts2.size();

            // 容差可根据实际情况微调，一般 0.1 对于平方值来说已经很严了
            if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

            return true;
        }

        // --- 兜底流程：如果无法获取点数据 ---
        // 这一步仅针对极少数异常情况，通常不会走到这里
        if (tpl->GetShape() != target->GetShape()) return false;

        // 宽高等于0的(Region)如果没有点数据，无法判断，认为是同类(或不同类看策略)
        // 这里沿用旧逻辑，避免崩溃
        double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
        double w2 = target->GetWidth(); double h2 = target->GetHeight();

        // 对于有尺寸的标准图形，如果没点，退化回宽/高比较
        if (IsEqual(w1, 0.0) && IsEqual(h1, 0.0)) return true; // 盲目信任

        // 仅支持 0/90 度兜底，任意角度无法通过 WH 判断
        if (IsEqual(w1, w2) && IsEqual(h1, h2)) return true;
        if (IsEqual(w1, h2) && IsEqual(h1, w2)) return true;

        return false;
    }


    bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
    {
        if (!tpl || !target) return false;

        // 1. 面积快速筛选
        // [调整] 面积容差稍微放宽，防止特定旋转角度计算误差被剔除
        if (!IsEqual(tpl->GetArea(), target->GetArea(), 0.25)) return false;

        const auto& pts1 = tpl->GetRefPoint();
        const auto& pts2 = target->GetRefPoint();

        // 2. 点数筛选
        // [关键修改] 移除严格的点数相等判断 (pts1.size() != pts2.size())
        // 原因：任意角度旋转后，提取算法产生的多边形顶点数可能相差1-2个点。
        // 改为允许少许差异 (例如相差超过 5 个点才认为不同)
        if (qAbs(pts1.size() - pts2.size()) > 5) return false;

        if (pts1.isEmpty()) return true;

        // 3. 几何指纹特征 (旋转不变量)
        QPointF c1 = tpl->GetCenterPoint();
        double maxR2_1 = 0.0;
        double sumR2_1 = 0.0;
        for (const auto& p : pts1) {
            double d2 = DistSq(p, c1);
            if (d2 > maxR2_1) maxR2_1 = d2;
            sumR2_1 += d2;
        }

        QPointF c2 = target->GetCenterPoint();
        double maxR2_2 = 0.0;
        double sumR2_2 = 0.0;
        for (const auto& p : pts2) {
            double d2 = DistSq(p, c2);
            if (d2 > maxR2_2) maxR2_2 = d2;
            sumR2_2 += d2;
        }

        // (A) 比较最大半径平方
        // [调整] 放宽到 1.0 (对应约 0.5mm 的 R 偏差平方)，适应较大焊盘
        if (qAbs(maxR2_1 - maxR2_2) > 1.0) return false;

        // (B) 比较平均半径平方
        double avgR2_1 = sumR2_1 / pts1.size();
        double avgR2_2 = sumR2_2 / pts2.size();

        // [调整] 放宽到 0.5
        if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

        return true;
    }
}

```


在之前的实验中，不管我怎么调整代码，纯几何匹配始终绕不开面积，周长，重心以及重心到各个点的距离


为了解决“拼版误差导致的漏报”与“容差过大导致的误报”之间的矛盾，我们需要引入一种**自适应的分级判定策略 (Adaptive Hierarchical Check)**，而不是简单地全局放宽或收紧。

**核心思路：**

1. **面积 (Area)** 是最抗噪的特征。拼版带来的坐标漂移对面积积分的影响极小。如果面积差异超过一定范围（如 2.5%），直接判为不同。
2. **周长 (Perimeter)** 受噪声影响极大（锯齿效应），我们**大幅降低其权重**，仅作极粗的筛选。
3. **形状细节 (Sorted Radii)** 采用**动态容差**：
    - 如果**面积非常接近**（说明大概率是同一个东西），我们可以稍稍放宽对形状细节的要求，以容忍采样噪声。
    - 如果**面积处于边缘**（差异较大），我们必须严格要求形状细节一致，以防止是两个不同但大小相近的形状。

这种方法可以在保留对拼版数据（相同面积，轻微变形）兼容性的同时，剔除大小相近但形状不同（误报）的目标


```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"
#include "GerberParser/GerberParser.hh"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
// --- 定义容差 ---
static const double CMP_EPSILON = 0.0001;
// 尺寸容差：0.025mm (微调：兼顾拼版偏移和小焊盘精度)
static const double DIM_TOLERANCE = 0.025;
// 相对误差容差：3.0% (适度放宽：解决 Image1/3 漏报问题)
static const double RELATIVE_TOLERANCE = 0.03;

// --- 辅助函数 ---
static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
{
    return qAbs(a - b) < epsilon;
}

static bool IsSimilar(double a, double b, double epsilon = DIM_TOLERANCE)
{
    return qAbs(a - b) < epsilon;
}

static double DistSq(const QPointF& p1, const QPointF& p2)
{
    double dx = p1.x() - p2.x();
    double dy = p1.y() - p2.y();
    return dx * dx + dy * dy;
}

    // --- 核心：基于轮廓点特征的严格比对 (支持任意角度) ---
    static bool IsSamePolygon(const QVector<QPointF>& pts1, const QVector<QPointF>& pts2)
    {
        // 0. 空检查
        if (pts1.isEmpty() || pts2.isEmpty()) return false;

        // 使用相对误差进行比较
        auto IsRelativeSimilar = [](double v1, double v2, double relTol, double absTol) -> bool {
            double diff = qAbs(v1 - v2);
            return diff < (qMax(v1, v2) * relTol + absTol); 
        };

        // 1. 几何特征计算：精确重心(Centroid)、面积、周长
        auto calcGeoFeatures = [](const QVector<QPointF>& pts, double& outArea, double& outPerimeter, QPointF& outCenter) {
            int n = pts.size();
            outArea = 0.0;
            outPerimeter = 0.0;
            outCenter = QPointF(0,0);
            
            if (n == 0) return;
            if (n < 3) { // 点或线
                 double cx=0, cy=0;
                 for(auto& p : pts){ cx+=p.x(); cy+=p.y(); }
                 outCenter = QPointF(cx/n, cy/n);
                 return;
            }

            // 平移以提高精度
            double meanX = 0, meanY = 0;
            for(const auto& p : pts) { meanX += p.x(); meanY += p.y(); }
            QPointF origin = QPointF(meanX / n, meanY / n);

            double signedArea2 = 0.0;
            double cx_sum = 0.0;
            double cy_sum = 0.0;

            for (int i = 0; i < n; ++i) {
                double x0 = pts[i].x() - origin.x();
                double y0 = pts[i].y() - origin.y();
                double x1 = pts[(i + 1) % n].x() - origin.x();
                double y1 = pts[(i + 1) % n].y() - origin.y();

                double cross = x0 * y1 - x1 * y0;
                signedArea2 += cross;
                
                cx_sum += (x0 + x1) * cross;
                cy_sum += (y0 + y1) * cross;

                double dx = x0 - x1;
                double dy = y0 - y1;
                outPerimeter += sqrt(dx*dx + dy*dy);
            }

            outArea = qAbs(signedArea2) * 0.5;

            if (outArea < 1e-6) {
                outCenter = origin; 
            } else {
                double factor = 1.0 / (3.0 * signedArea2);
                outCenter = QPointF(origin.x() + cx_sum * factor, 
                                    origin.y() + cy_sum * factor);
            }
        };

        double area1, peri1, area2, peri2;
        QPointF c1, c2;
        calcGeoFeatures(pts1, area1, peri1, c1);
        calcGeoFeatures(pts2, area2, peri2, c2);

        // 2. 面积比对 (3.0%) - 放宽至3%以接纳 Image1/3 的拼版变形
        double maxArea = qMax(area1, area2);
        double areaDiff = qAbs(area1 - area2);
        double areaErrRatio = (maxArea > 1e-9) ? (areaDiff / maxArea) : 0.0;

        if (areaErrRatio > 0.03 && areaDiff > 0.03) return false;

        // 3. 周长比对 (保持10%)
        if (!IsRelativeSimilar(peri1, peri2, 0.10, 0.10)) {
             int n1 = pts1.size();
             int n2 = pts2.size();
             if (qAbs(n1 - n2) < 5) return false;
        }

        // 4. 计算半径特征
        QVector<double> r1, r2;
        r1.reserve(pts1.size());
        r2.reserve(pts2.size());
        
        for (const auto& p : pts1) r1.append(DistSq(p, c1));
        for (const auto& p : pts2) r2.append(DistSq(p, c2));

        std::sort(r1.begin(), r1.end());
        std::sort(r2.begin(), r2.end());

        // 5. 动态阈值的半径分布比对
        // 关键调整：大幅降低绝对误差底噪 (0.005 -> 0.001) 以解决 Image2 小焊盘误报
        // 同时适当放宽相对比例，以解决 Image1/3 漏报
        
        // 基础相对误差
        double allowedRadiusErr = 0.02;
        
        if (areaErrRatio < 0.015) { 
            // 高置信度 (面积差异 < 1.5%) -> 放宽形状匹配至 4.5%
            allowedRadiusErr = 0.045; 
        } else {
            // 低置信度 (面积差异 1.5%~3%) -> 收紧形状匹配至 2.5%
            allowedRadiusErr = 0.025;
        }

        int n1 = r1.size();
        int n2 = r2.size();

        if (n1 == n2) {
            double maxR2 = qMax(r1.last(), r2.last());
            if (maxR2 < 1e-9) return true;

            // [新增] 强制检查最大半径 (对角线长度平方)
            // 即使平均半径接近，如果最大半径差异大(如圆角矩形 vs 直角矩形)，也应拒绝
            // 阈值设为 3.0% (平方域)
            if (qAbs(r1.last() - r2.last()) > (maxR2 * 0.03 + 0.002)) return false;

            double totalDiff = 0.0;
            for (int i = 0; i < n1; ++i) {
                totalDiff += qAbs(r1[i] - r2[i]);
            }
            double avgDiff = totalDiff / n1;
            
            // 使用动态阈值 + 极低的绝对误差底噪(0.001)
            if (avgDiff > (maxR2 * allowedRadiusErr + 0.001)) return false;
            
        } else {
             // 点数不同
             double maxR2_1 = r1.last();
             double maxR2_2 = r2.last();
             
             if (!IsRelativeSimilar(maxR2_1, maxR2_2, 0.03, 0.03)) return false;

             double sum1 = 0; for(double v:r1) sum1+=sqrt(v);
             double sum2 = 0; for(double v:r2) sum2+=sqrt(v);
             double avg1 = sum1/n1;
             double avg2 = sum2/n2;
             
             if (!IsRelativeSimilar(avg1, avg2, allowedRadiusErr, 0.02)) return false;
        }

        return true;
    }



    bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
    {
        if (!tpl || !target) return false;

        // 形状大类检查
        // 注意：有些CAM软件会在镜像/旋转后将标准形状(Rect)转为Polgyon
        // 如果我们要支持跨类型匹配（Reg <-> Poly），需要更复杂的逻辑。
        //这里暂时保留严格类型检查，如遇到Rect匹配Poly的情况需在外部处理或Relax此检查
        if (tpl->GetShape() != target->GetShape()) return false;

        int shapeType = tpl->GetShape();
        bool isRegularShape = (shapeType != GERB_SHAPE_POLYGON && shapeType != GERB_SHAPE_AMACRO);

        if (isRegularShape)
        {
            // === 正常标准形状 (Rect, Circle, etc) ===
            // 对于标准形状，支持任意角度旋转的最简单方法是：比较排序后的长宽
            // 只要短边等于短边，长边等于长边，那就是同一个形状（无论怎么转）

            double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
            double w2 = target->GetWidth(); double h2 = target->GetHeight();

            // 排除 0,0 的无效数据情况
            if (IsEqual(w1,0) && IsEqual(h1,0)) return false;

            double min1 = qMin(w1, h1); double max1 = qMax(w1, h1);
            double min2 = qMin(w2, h2); double max2 = qMax(w2, h2);

            // 使用 IsSimilar (0.05mm) 而不是 IsEqual (0.0001mm)
            if (!IsSimilar(min1, min2)) return false;
            if (!IsSimilar(max1, max2)) return false;

            return true;
        }
        else
        {
            // === 异形焊盘 (Polygon) ===
            const QVector<QPointF>& pts1 = tpl->GetPoint();
            const QVector<QPointF>& pts2 = target->GetPoint();
            return IsSamePolygon(pts1, pts2);
        }
    }



bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
{
    if (!tpl || !target) return false;

    // 初步面积筛查
    double a1 = tpl->GetArea();
    double a2 = target->GetArea();
    // 相对误差检查 (调至 3.0%，接纳拼版变形)
    if (qAbs(a1 - a2) > (qMax(a1,a2) * 0.03 + 0.01)) return false;

    const auto& pts1 = tpl->GetRefPoint();
    const auto& pts2 = target->GetRefPoint();

    // 简单焊盘 (无轮廓点)
    if (pts1.isEmpty() && pts2.isEmpty())
    {
        // 修改：使用包围盒获取宽高
        // 假设接口为 GetBoundingBox() 返回 QRectF (根据 GerberPad 定义推断)
        QRectF box1 = tpl->GetBoundingBox();
        QRectF box2 = target->GetBoundingBox();

        double w1 = box1.width();
        double h1 = box1.height();
        double w2 = box2.width();
        double h2 = box2.height();

        // 放宽容差：使用 IsSimilar (0.05mm)
        // 严格尺寸匹配
        if (IsSimilar(w1, w2) && IsSimilar(h1, h2)) return true;
        // 90度旋转匹配
        if (IsSimilar(w1, h2) && IsSimilar(h1, w2)) return true;

        return false;
    }

    // 结构不一致 (一个有轮廓，一个没有)
    if (pts1.isEmpty() != pts2.isEmpty()) return false;

    // 异形焊盘：使用严格几何比对
    // (周长、计算包围盒)
    return IsSamePolygon(pts1, pts2);
    }
}

```


EditWidget.cpp
```C++
void EditWidget::on_toolButton_similarPads_clicked()
{
    // 1. 获取场景
    if (!ui->widget_view || !ui->widget_view->GetImageView()) return;
    QGraphicsScene* pScene = ui->widget_view->GetImageView()->Scene();
    if (!pScene) return;

    // 2. 获取当前选中的 Items (作为模板)
    QList<QGraphicsItem*> selectedItems = ui->widget_view->GetImageView()->GetSelectedItems();
    if (selectedItems.isEmpty()) {
        LOG_INFO("not choose any pad as template");
        return;
    }

    // [修改说明]
    // 移除基于 DCode 的快速筛选逻辑 (templateDCodes)。
    // 之前的逻辑会导致：如果模板有D码，它只会被记录D码，而不会进入几何特征列表。
    // 这会导致 "同形状但不同D码" 的焊盘无法匹配 (因为几何列表为空)。
    // 现在我们将所有选中的焊盘都有作为几何模板，调用 IsSameGerberInfo 进行统一的 robust 匹配。

    QList<GerberInfo*> preTemplatesGeom;
    QList<CGerberPadInfo*> postTemplates;

    for (QGraphicsItem* item : selectedItems)
    {
        // 类型转换：PadItem (提取前)
        PadItem* pItem = dynamic_cast<PadItem*>(item);
        if (pItem && pItem->getGerberInfo()) {
            GerberInfo* info = pItem->getGerberInfo();
            // 不再区分是否有 DCode，全部加入几何匹配流程
            preTemplatesGeom.append(info);
            continue;
        }

        // 类型转换：CGerberPadItem (提取后)
        CGerberPadItem* cpItem = dynamic_cast<CGerberPadItem*>(item);
        if (cpItem) {
            postTemplates.append(cpItem->getGerberInfo());
            continue;
        }
    }

    QString logMsg = QString("Templates: Gerber(Pre)=%0, Extracted(Post)=%1")
                         .arg(preTemplatesGeom.count()).arg(postTemplates.count());
    LOG_INFO(logMsg.toUtf8().constData());

    if (preTemplatesGeom.isEmpty() && postTemplates.isEmpty()) return;

    // 3. 遍历全场进行匹配
    bool wasBlocked = pScene->blockSignals(true); // 提升性能
    QList<QGraphicsItem*> allItems = pScene->items();
    int newCount = 0;

    for (QGraphicsItem* item : allItems)
    {
        if (item->isSelected()) continue;

        bool isMatch = false;

        // --- 匹配 PadItem (提取前) ---
        PadItem* target = dynamic_cast<PadItem*>(item);
        if (target && target->getGerberInfo()) {
            GerberInfo* tInfo = target->getGerberInfo();

            // 使用统一的几何特征匹配
            // 不再使用 DCode shortcut，确保不同 DCode 但形状相同的焊盘能被匹配
            for (GerberInfo* tpl : preTemplatesGeom) {
                if (Vision::IsSameGerberInfo(tpl, tInfo))
                {
                    isMatch = true;
                    break;
                }
            }
        }

        // 匹配 CGerberPadItem (提取后)
        if (!isMatch && !postTemplates.isEmpty()) {
            CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item);
            if (extractTarget && extractTarget->getGerberInfo()) {
                CGerberPadInfo* tInfo = extractTarget->getGerberInfo();
                for (CGerberPadInfo* tpl : postTemplates) {
                    if (Vision::IsSameCGerberPadInfo(tpl, tInfo)) {
                        isMatch = true;
                        break;
                    }
                }
            }
        }

        if (isMatch) {
            // 设置选中状态
            if (target) {
                target->SetSelectState(true);
            } else if (CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item)) {
                extractTarget->SetSelectState(true);
            }
            newCount++;
        }
    }

    pScene->blockSignals(wasBlocked);

    // 4. 刷新界面
    if (newCount > 0)
    {
        // 重新统计，确保 View 和 Model 数量一致
        QList<QGraphicsItem*> finalSelected = ui->widget_view->GetImageView()->GetSelectedItems();
        emit ui->widget_view->GetImageView()->signalSelectNum(finalSelected.count());
        ui->widget_view->GetImageView()->viewport()->update();
        LOG_INFO(QString("Matched %0 similar pads.").arg(newCount).toLocal8Bit());
    }
}

}```



ImageView.cpp
```C++
QList<QGraphicsItem*> ImageView::GetSelectedItems()
{
    QList<QGraphicsItem*> list;  //创建空列表来存储选中的item

    // 获取图层列表 
    QMap<QString, QGraphicsItemGroup *> groups = GetImageLayers(); //GetImageLayers()返回一个映射（QMap）,其中键（key）是图层的名称（QString），值（value）是当前图层中所选中的item。

    for (auto it = groups.begin(); it != groups.end(); ++it)  //遍历每一个图层
    {
        QGraphicsItemGroup* group = it.value();  //当前图层所有选中的item

        if (!group || !group->isVisible())   //当前图层是否有效且可见
            continue;
            
        LayerType type = group->data(Qt::UserRole + 1).value<LayerType>();  //从每一份图层中获取类型；在QT中使用data方法为对象存储自定义数据，这里使用Qt::UserRole + 1作为键来获取存储的数据，并将其转换为LayerType枚举类型（CAD，GERBER——PAD，GERBER）
        for (QGraphicsItem* item : group->childItems())   //遍历图层的每个选中的item
        {
            bool isSelected = false;

            if (type == LayerType::CAD)
            {
                CrossItem* crossItem = dynamic_cast<CrossItem*>(item); //如果选中的item是CAD，就将图形item转换为CrossItem，这里使用的是dynamic_cast（安全地向下转型），它是C++中的一个类型转换操作符，主要用于多态类型之间的转换，将基类指针或引用转换为派生类指针或引用，这是dynamic_cast最常见的用途。
                if (crossItem && crossItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER_PAD)
            {
                CGerberPadItem* padItem = dynamic_cast<CGerberPadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER)
            {
                PadItem* padItem = dynamic_cast<PadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }

            if (isSelected)
            {
                list.append(item);   //如果图形被选中，就添加到列表
            }
        }
    }
    return list;
}
```