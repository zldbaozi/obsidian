PadMatcher.h
```C++
#ifndef MT_GERBERPARSER_H_
#define MT_GERBERPARSER_H_

#include "GerberParserExport.h"
#include <QPointF>
#include <QRectF>
#include <QString>
#include <QList>
#include <QVector>

class GerberInfo;
class CGerberPadInfo;

namespace Vision
{
    enum GerberShapeType
    {
        GERB_SHAPE_LINE = 0,    ///<线段
        GERB_SHAPE_ARC,         ///<圆弧
        GERB_SHAPE_CIRCLE,      ///<圆
        GERB_SHAPE_ELLIPSE,     ///<椭圆
        GERB_SHAPE_RECTANGLE,   ///<矩形
        GERB_SHAPE_POLYGON,     ///<多边形
        GERB_SHAPE_AMACRO       ///<自定义
    };

    struct GerberShape
    {
        GerberShapeType type;   //形状类型

        double width;           //根据形状变化，线宽，矩形宽度
        double height;          //矩行宽度
        double angle1;          //圆弧起始角度
        double angle2;          //圆弧终点角度

        QVector<QPointF> points; //线段[0,1], 圆弧、圆、椭圆、矩形[0], 多边形所有点
        QString dcode;            //D码
        GerberShapeType stype;    //原始形状类型
        QVector<QPointF> spoints; //原始点
    };
    
    struct RectAngle
    {
        QPointF center;
        double width;
        double height;
        double angle;
    };

    struct GerberPad
    {
        QRectF           boundingBox;   //外接矩形
        RectAngle        rotateBox;     //旋转矩形
        double           area;          //面积
        QVector<QPointF> points;        //轮廓点
    };

    /**
     * @brief 解析gerber
     * @param[in,out] : path   gerber文件路径
     * @param[in,out] : shapes 返回解析的形状用于绘图
     * @return GBP_EXPORT
     */
    GBP_EXPORT int GerberParser(const QString& path, QList<GerberShape>& shapes);

    /**
     * @brief 提取焊盘
     * @param[in,out] : shapes 解析的形状
     * @param[in,out] : pads   返回合并的焊盘形状
     * @return GBP_EXPORT
     */
    GBP_EXPORT int ExtractShapes(const QList<GerberShape>& shapes, QList<GerberPad>& pads);

    // --- (新增) 相似焊盘匹配接口 ---
    /**
     * @brief 判断两个提取前焊盘(GerberInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target);

    /**
     * @brief 判断两个提取后焊盘(CGerberPadInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target);
}

#endif
```


PadMatcher.cpp
```C++
#include "PadMatcher.h"
#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
    // --- 定义容差 ---
    static const double CMP_EPSILON = 0.0005;
    static const double AREA_EPSILON = 0.005;
    static const double DIST_EPSILON = 0.0005;
    // --- 辅助函数 ---
    static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
    {
        return qAbs(a - b) < epsilon;
    }

    static double DistSq(const QPointF& p1, const QPointF& p2)
    {
        double dx = p1.x() - p2.x();
        double dy = p1.y() - p2.y();
        return dx * dx + dy * dy;
    }

    bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
    {
        if (!tpl || !target) return false;
        
        const std::string& dcode1 = tpl->GetDcode();
        const std::string& dcode2 = target->GetDcode();
        
        if (!dcode1.empty() && !dcode2.empty())
        {
            return dcode1 == dcode2;
        }
        
        // 几何形状匹配
        if (tpl->GetShape() != target->GetShape()) return false;
        // 宽和高判断
        if (!IsEqual(tpl->GetWidth(), target->GetWidth())) return false;
        if (!IsEqual(tpl->GetHeight(), target->GetHeight())) return false;

        return true;
    }

    bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
    {
        if (!tpl || !target) return false;
        // 1. 面积快速筛选 (最基本条件)
        // 合并后的焊盘面积 = 两个原始焊盘面积之和（减去重叠部分），只要是同一类合并，面积必然相等
        if (!IsEqual(tpl->GetArea(), target->GetArea(), AREA_EPSILON)) return false;

        // 2. 包围盒尺寸筛选 (应对粘连形状)
        // 如果两个焊盘粘连，如果是横着粘，宽变大；竖着粘，高变大。
        // 比较包围盒的宽高。为了支持90度旋转，比较 (短边, 长边)。

        QRectF box1 = tpl->GetBoundingBox();
        QRectF box2 = target->GetBoundingBox();

        double w1 = box1.width();
        double h1 = box1.height();
        double w2 = box2.width();
        double h2 = box2.height();

        // 排序获取短边和长边，实现90度旋转不敏感
        double min1 = qMin(w1, h1); double max1 = qMax(w1, h1);
        double min2 = qMin(w2, h2); double max2 = qMax(w2, h2);

        // 稍微放宽容差，因为提取算法计算包围盒可能有轻微误差
        if (!IsEqual(min1, min2, 0.01)) return false;
        if (!IsEqual(max1, max2, 0.01)) return false;

        // 3. 点数筛选 (轮廓复杂度一致)
        const auto& pts1 = tpl->GetRefPoint();
        const auto& pts2 = target->GetRefPoint();

        if (pts1.size() != pts2.size()) return false;
        if (pts1.isEmpty()) return true;

        // 4. 高级特征：中心距指纹 (Hash校验)
        QPointF c1 = tpl->GetCenterPoint();
        double sumDistSq1 = 0.0;
        for (const QPointF& p : pts1) sumDistSq1 += DistSq(p, c1);

        QPointF c2 = target->GetCenterPoint();
        double sumDistSq2 = 0.0;
        for (const QPointF& p : pts2) sumDistSq2 += DistSq(p, c2);

        // 比较所有点到中心的距离总和（比只比较min/max更稳定）
        // 距离越大，容差需要适当放大，这里用相对误差或者较大的固定误差
        if (!IsEqual(std::sqrt(sumDistSq1), std::sqrt(sumDistSq2), 0.1)) return false;

        return true;
    }
}
```



EditWidget.cpp
```C++
void EditWidget::on_toolButton_similarPads_clicked()
{
    // 1. 获取场景
    if (!ui->widget_view || !ui->widget_view->GetImageView()) return;
    QGraphicsScene* pScene = ui->widget_view->GetImageView()->Scene();
    if (!pScene) return;
  
    // 2. 获取当前选中的 Items 
    QList<QGraphicsItem*> selectedItems = ui->widget_view->GetImageView()->GetSelectedItems();
    if (selectedItems.isEmpty()) {
        LOG_INFO("not choose any pad as template");
        return;
    }
  
    // templateDCodes: 用于存储选中的 D码 (std::string)，这是最快最准的匹配方式
    std::unordered_set<std::string> templateDCodes;
    // preTemplatesGeom: 如果没有D码，则回退到几何特征匹配
    QList<GerberInfo*> preTemplatesGeom;
    //处理提取后的焊盘
    QList<CGerberPadInfo*> postTemplates;
  
    for (QGraphicsItem* item : selectedItems)
    {
        // 类型转换：PadItem (提取前)
        PadItem* pItem = dynamic_cast<PadItem*>(item);
        if (pItem && pItem->getGerberInfo()) {
            std::string dcode = pItem->getGerberInfo()->GetDcode();
            // 如果D码有效且不是空的，直接用D码匹配
            if (!dcode.empty()) {
                templateDCodes.insert(dcode);
            } else {
                // 没有D码的特殊图形，记录几何信息做兜底
                preTemplatesGeom.append(pItem->getGerberInfo());
            }
            continue;
        }

        // 类型转换：CGerberPadItem (提取后)
        CGerberPadItem* cpItem = dynamic_cast<CGerberPadItem*>(item);
        if (cpItem) {
            postTemplates.append(cpItem->getGerberInfo());
            continue;
        }
    }
    
    QString logMsg = QString("Templates: DCode(Map)=%0, Geometry(Fallback)=%1, Extracted(Post)=%2")                         .arg(templateDCodes.size()).arg(preTemplatesGeom.count()).arg(postTemplates.count());
    LOG_INFO(logMsg.toUtf8().constData());

    if (templateDCodes.empty() && preTemplatesGeom.isEmpty() && postTemplates.isEmpty()) return;

    // 3. 遍历全场进行匹配
    bool wasBlocked = pScene->blockSignals(true); // 提升性能
    QList<QGraphicsItem*> allItems = pScene->items();
    int newCount = 0;

    // 定义浮点数比较精度的 lambda (用于无D码的情况)
    auto fuzzyMatch = [](double a, double b) {
        return std::abs(a - b) < 0.0001;
    };

    for (QGraphicsItem* item : allItems)
    {
        if (item->isSelected()) continue;

        bool isMatch = false;

        // --- 匹配 PadItem (提取前) ---
        PadItem* target = dynamic_cast<PadItem*>(item);
        if (target && target->getGerberInfo()) {
            GerberInfo* tInfo = target->getGerberInfo();
            std::string tDcode = tInfo->GetDcode();
            
            // 策略A: D码匹配 (优先，极速)
            if (!tDcode.empty()) {
                if (templateDCodes.count(tDcode)) {
                    isMatch = true;
                }
            }

            // 策略B: 几何特征匹配 (兜底)
            else if (!preTemplatesGeom.isEmpty()) {
                for (GerberInfo* tpl : preTemplatesGeom) {

                    if (tpl->GetShape() == tInfo->GetShape() &&

                        fuzzyMatch(tpl->GetWidth(), tInfo->GetWidth()) &&

                        fuzzyMatch(tpl->GetHeight(), tInfo->GetHeight()))

                    {

                        if (tpl->GetShape() == 1 || fuzzyMatch(tpl->GetAngle(), tInfo->GetAngle()))

                        {

                            isMatch = true;

                            break;

                        }

                    }

                }

            }

        }

  

        // --- 匹配 CGerberPadItem (提取后) ---

        // 只有当前面没匹配上才尝试

        if (!isMatch && !postTemplates.isEmpty()) {

            CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item);

            if (extractTarget && extractTarget->getGerberInfo()) {

                CGerberPadInfo* tInfo = extractTarget->getGerberInfo();

                for (CGerberPadInfo* tpl : postTemplates) {

                    // 直接调用修改后的强力匹配函数

                    if (Vision::IsSameCGerberPadInfo(tpl, tInfo)) {

                        isMatch = true;

                        break;

                    }

                }

            }

        }

  

        if (isMatch) {

            // 设置选中状态

            if (target) {

                target->SetSelectState(true);

  

                // 【调试信息：打印匹配到的 PadItem 详情】

                if (target->getGerberInfo()) {

                    GerberInfo* inf = target->getGerberInfo();

                    QString debugMsg = QString("Matched PadItem -> DCode:%1 Shape:%2 W:%3 H:%4 Angle:%5")

                                           .arg(QString::fromStdString(inf->GetDcode()))

                                           .arg(inf->GetShape())

                                           .arg(inf->GetWidth(), 0, 'f', 4)

                                           .arg(inf->GetHeight(), 0, 'f', 4)

                                           .arg(inf->GetAngle(), 0, 'f', 2);

                    LOG_INFO(debugMsg.toLocal8Bit().constData());

                }

            }

  

            CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item);

            if (extractTarget) {

                extractTarget->SetSelectState(true);

  

                // 【调试信息：打印匹配到的 CGerberPadItem 详情】

                if (extractTarget->getGerberInfo()) {

                    CGerberPadInfo* inf = extractTarget->getGerberInfo();

                    QRectF r = inf->GetBoundingBox();

                    QString debugMsg = QString("Matched ExtractedPad -> Area:%1 Box:[%2 x %3]")

                                           .arg(inf->GetArea(), 0, 'f', 4)

                                           .arg(r.width(), 0, 'f', 4)

                                           .arg(r.height(), 0, 'f', 4);

                    LOG_INFO(debugMsg.toLocal8Bit().constData());

                }

            }

  

            newCount++;

        }

    }

  

    pScene->blockSignals(wasBlocked);

  

    // 4. 刷新界面

    if (newCount > 0)

    {

        // 重新统计，确保 View 和 Model 数量一致

        QList<QGraphicsItem*> finalSelected = ui->widget_view->GetImageView()->GetSelectedItems();

        emit ui->widget_view->GetImageView()->signalSelectNum(finalSelected.count());

        ui->widget_view->GetImageView()->viewport()->update();

        LOG_INFO(QString("Matched %0 similar pads.").arg(newCount).toLocal8Bit());

    }

  

}
```



ImageView.cpp
```C++
QList<QGraphicsItem*> ImageView::GetSelectedItems()
{
    QList<QGraphicsItem*> list;  //创建空列表来存储选中的item

    // 获取图层列表 
    QMap<QString, QGraphicsItemGroup *> groups = GetImageLayers(); //GetImageLayers()返回一个映射（QMap）,其中键（key）是图层的名称（QString），值（value）是当前图层中所选中的item。

    for (auto it = groups.begin(); it != groups.end(); ++it)  //遍历每一个图层
    {
        QGraphicsItemGroup* group = it.value();  //当前图层所有选中的item

        if (!group || !group->isVisible())   //当前图层是否有效且可见
            continue;
            
        LayerType type = group->data(Qt::UserRole + 1).value<LayerType>();  //从每一份图层中获取类型；在QT中使用data方法为对象存储自定义数据，这里使用Qt::UserRole + 1作为键来获取存储的数据，并将其转换为LayerType枚举类型（CAD，GERBER——PAD，GERBER）
        for (QGraphicsItem* item : group->childItems())   //遍历图层的每个选中的item
        {
            bool isSelected = false;

            if (type == LayerType::CAD)
            {
                CrossItem* crossItem = dynamic_cast<CrossItem*>(item); //如果选中的item是CAD，就将图形item转换为CrossItem，这里使用的是dynamic_cast（安全地向下转型），它是C++中的一个类型转换操作符，主要用于多态类型之间的转换，将基类指针或引用转换为派生类指针或引用，这是dynamic_cast最常见的用途。
                if (crossItem && crossItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER_PAD)
            {
                CGerberPadItem* padItem = dynamic_cast<CGerberPadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER)
            {
                PadItem* padItem = dynamic_cast<PadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }

            if (isSelected)
            {
                list.append(item);   //如果图形被选中，就添加到列表
            }
        }
    }
    return list;
}
```