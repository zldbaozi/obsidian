PadMatcher.h
```C++
#ifndef MT_GERBERPARSER_H_
#define MT_GERBERPARSER_H_

#include "GerberParserExport.h"
#include <QPointF>
#include <QRectF>
#include <QString>
#include <QList>
#include <QVector>

class GerberInfo;
class CGerberPadInfo;

namespace Vision
{
    enum GerberShapeType
    {
        GERB_SHAPE_LINE = 0,    ///<线段
        GERB_SHAPE_ARC,         ///<圆弧
        GERB_SHAPE_CIRCLE,      ///<圆
        GERB_SHAPE_ELLIPSE,     ///<椭圆
        GERB_SHAPE_RECTANGLE,   ///<矩形
        GERB_SHAPE_POLYGON,     ///<多边形
        GERB_SHAPE_AMACRO       ///<自定义
    };

    struct GerberShape
    {
        GerberShapeType type;   //形状类型

        double width;           //根据形状变化，线宽，矩形宽度
        double height;          //矩行宽度
        double angle1;          //圆弧起始角度
        double angle2;          //圆弧终点角度

        QVector<QPointF> points; //线段[0,1], 圆弧、圆、椭圆、矩形[0], 多边形所有点
        QString dcode;            //D码
        GerberShapeType stype;    //原始形状类型
        QVector<QPointF> spoints; //原始点
    };
    
    struct RectAngle
    {
        QPointF center;
        double width;
        double height;
        double angle;
    };

    struct GerberPad
    {
        QRectF           boundingBox;   //外接矩形
        RectAngle        rotateBox;     //旋转矩形
        double           area;          //面积
        QVector<QPointF> points;        //轮廓点
    };

    /**
     * @brief 解析gerber
     * @param[in,out] : path   gerber文件路径
     * @param[in,out] : shapes 返回解析的形状用于绘图
     * @return GBP_EXPORT
     */
    GBP_EXPORT int GerberParser(const QString& path, QList<GerberShape>& shapes);

    /**
     * @brief 提取焊盘
     * @param[in,out] : shapes 解析的形状
     * @param[in,out] : pads   返回合并的焊盘形状
     * @return GBP_EXPORT
     */
    GBP_EXPORT int ExtractShapes(const QList<GerberShape>& shapes, QList<GerberPad>& pads);

    // --- (新增) 相似焊盘匹配接口 ---
    /**
     * @brief 判断两个提取前焊盘(GerberInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target);

    /**
     * @brief 判断两个提取后焊盘(CGerberPadInfo)是否属于同类型
     * @param tpl 模版焊盘
     * @param target 目标焊盘
     * @return true 相同, false 不同
     */
    GBP_EXPORT bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target);
}

#endif
```


PadMatcher.cpp
```C++
#include "PadMatcher.h"

#include "Logic/GerberInfo.h"
#include "Logic/CGerberPadInfo.h"
#include "ILogger.h"

#include <QtMath>
#include <limits>
#include <string>

namespace Vision
{
    // --- 定义容差 ---
    static const double CMP_EPSILON = 0.0001;
    static const double AREA_EPSILON = 0.15;
    static const double DIST_EPSILON = 0.05;

    // --- 辅助函数 ---
    static bool IsEqual(double a, double b, double epsilon = CMP_EPSILON)
    {
        return qAbs(a - b) < epsilon;
    }
    
	// 计算两点距离的平方（不开方，提高性能）
    static double DistSq(const QPointF& p1, const QPointF& p2)
    {
        double dx = p1.x() - p2.x();
        double dy = p1.y() - p2.y();
        return dx * dx + dy * dy;
    }


    bool IsSameGerberInfo(GerberInfo* tpl, GerberInfo* target)
    {
        if (!tpl || !target) return false;

        const QVector<QPointF>& pts1 = tpl->GetPoint();
        const QVector<QPointF>& pts2 = target->GetPoint();

        // --- 核心：基于“旋转不变量”的几何特征比对 ---
        // 任何角度旋转，以下特征应当保持不变：
        // 1. 面积 (Area)
        // 2. 质心到轮廓点的最大距离 (Max Radius)
        // 3. 距离分布指纹 (Radius Variance/Sum)

        // 辅助 lambda：计算多边形面积和质心(重心)
        auto getAreaAndCenter = [](const QVector<QPointF>& pts, double& area, QPointF& center) {
            area = 0.0;
            double cx = 0.0, cy = 0.0;
            int n = pts.size();   //顶点数

            // 简单重心计算(顶点平均值)，对于凸多边形作为特征点足够稳定
            // 如果追求极致精确应使用多边形质心公式，但耗时更多
            if (n > 0) {
                for(const auto& p : pts) {
                    cx += p.x();
                    cy += p.y();
                }
                center = QPointF(cx / n, cy / n);
            }

            if(n < 3) { area=0; return; }
            for (int i = 0; i < n; ++i) {
                area += (pts[i].x() * pts[(i + 1) % n].y() - pts[(i + 1) % n].x() * pts[i].y());
            }
            area = qAbs(area) * 0.5;
        };

        // 辅助 lambda：计算旋转不变特征 (最大半径 & 半径平方和)
        auto getInvariantFeatures = [](const QVector<QPointF>& pts, const QPointF& center, double& maxR2, double& sumR2) {
            maxR2 = 0.0;
            sumR2 = 0.0;
            for (const auto& p : pts) {
                double dx = p.x() - center.x();
                double dy = p.y() - center.y();
                double d2 = dx*dx + dy*dy;
                if (d2 > maxR2) maxR2 = d2;
                sumR2 += d2;
            }
        };

        // --- 优先流程：基于点集的任意角度特征比对 ---
        if (!pts1.isEmpty() && !pts2.isEmpty())
        {
	        // 顶点数量检查，防止出现面积相同但不是同类的情况
            if (qAbs(pts1.size() - pts2.size()) > 5) return false;
            
            double area1, area2;
            QPointF c1, c2;

            getAreaAndCenter(pts1, area1, c1);
            getAreaAndCenter(pts2, area2, c2);

            // 1. 面积比对 (最基础筛选)
            if (qAbs(area1 - area2) > 0.1) return false;

            // 2. 几何指纹比对 (支持任意角度旋转)
            double maxR2_1, sumR2_1;
            double maxR2_2, sumR2_2;

            getInvariantFeatures(pts1, c1, maxR2_1, sumR2_1);
            getInvariantFeatures(pts2, c2, maxR2_2, sumR2_2);

            // 比较最大半径平方 (Max Radius Squared)
            if (qAbs(maxR2_1 - maxR2_2) > 0.3) return false;

            // 比较半径平方和 (Radius Squared Sum) - 类似于惯性矩的比对
            // 由于点数可能不同(尤其是圆/弧离散化后)，归一化处理比较好
            // 但如果 Gerber 生成方式一致，直接比较总和也是可行的
            // 这里为了稳健，如果点数差异巨大(比如差了一倍)，可能导致sum不同，
            // 建议先判定点数是否在一个数量级。

            // 为了解决不同拼版点数采样可能略有不同的问题，我们使用 "平均半径平方"
            double avgR2_1 = pts1.isEmpty() ? 0 : sumR2_1 / pts1.size();
            double avgR2_2 = pts2.isEmpty() ? 0 : sumR2_2 / pts2.size();

            // 容差可根据实际情况微调，一般 0.1 对于平方值来说已经很严了
            if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

            return true;
        }

        // --- 兜底流程：如果无法获取点数据 ---
        // 这一步仅针对极少数异常情况，通常不会走到这里
        if (tpl->GetShape() != target->GetShape()) return false;

        // 宽高等于0的(Region)如果没有点数据，无法判断，认为是同类(或不同类看策略)
        // 这里沿用旧逻辑，避免崩溃
        double w1 = tpl->GetWidth(); double h1 = tpl->GetHeight();
        double w2 = target->GetWidth(); double h2 = target->GetHeight();

        // 对于有尺寸的标准图形，如果没点，退化回宽/高比较
        if (IsEqual(w1, 0.0) && IsEqual(h1, 0.0)) return true; // 盲目信任

        // 仅支持 0/90 度兜底，任意角度无法通过 WH 判断
        if (IsEqual(w1, w2) && IsEqual(h1, h2)) return true;
        if (IsEqual(w1, h2) && IsEqual(h1, w2)) return true;

        return false;
    }


    bool IsSameCGerberPadInfo(CGerberPadInfo* tpl, CGerberPadInfo* target)
    {
        if (!tpl || !target) return false;

        // 1. 面积快速筛选
        // [调整] 面积容差稍微放宽，防止特定旋转角度计算误差被剔除
        if (!IsEqual(tpl->GetArea(), target->GetArea(), 0.25)) return false;

        const auto& pts1 = tpl->GetRefPoint();
        const auto& pts2 = target->GetRefPoint();

        // 2. 点数筛选
        // [关键修改] 移除严格的点数相等判断 (pts1.size() != pts2.size())
        // 原因：任意角度旋转后，提取算法产生的多边形顶点数可能相差1-2个点。
        // 改为允许少许差异 (例如相差超过 5 个点才认为不同)
        if (qAbs(pts1.size() - pts2.size()) > 5) return false;

        if (pts1.isEmpty()) return true;

        // 3. 几何指纹特征 (旋转不变量)
        QPointF c1 = tpl->GetCenterPoint();
        double maxR2_1 = 0.0;
        double sumR2_1 = 0.0;
        for (const auto& p : pts1) {
            double d2 = DistSq(p, c1);
            if (d2 > maxR2_1) maxR2_1 = d2;
            sumR2_1 += d2;
        }

        QPointF c2 = target->GetCenterPoint();
        double maxR2_2 = 0.0;
        double sumR2_2 = 0.0;
        for (const auto& p : pts2) {
            double d2 = DistSq(p, c2);
            if (d2 > maxR2_2) maxR2_2 = d2;
            sumR2_2 += d2;
        }

        // (A) 比较最大半径平方
        // [调整] 放宽到 1.0 (对应约 0.5mm 的 R 偏差平方)，适应较大焊盘
        if (qAbs(maxR2_1 - maxR2_2) > 1.0) return false;

        // (B) 比较平均半径平方
        double avgR2_1 = sumR2_1 / pts1.size();
        double avgR2_2 = sumR2_2 / pts2.size();

        // [调整] 放宽到 0.5
        if (qAbs(avgR2_1 - avgR2_2) > 0.3) return false;

        return true;
    }
}

```



EditWidget.cpp
```C++
void EditWidget::on_toolButton_similarPads_clicked()
{
    // 1. 获取场景
    if (!ui->widget_view || !ui->widget_view->GetImageView()) return;
    QGraphicsScene* pScene = ui->widget_view->GetImageView()->Scene();
    if (!pScene) return;

    // 2. 获取当前选中的 Items (作为模板)
    QList<QGraphicsItem*> selectedItems = ui->widget_view->GetImageView()->GetSelectedItems();
    if (selectedItems.isEmpty()) {
        LOG_INFO("not choose any pad as template");
        return;
    }

    // [修改说明]
    // 移除基于 DCode 的快速筛选逻辑 (templateDCodes)。
    // 之前的逻辑会导致：如果模板有D码，它只会被记录D码，而不会进入几何特征列表。
    // 这会导致 "同形状但不同D码" 的焊盘无法匹配 (因为几何列表为空)。
    // 现在我们将所有选中的焊盘都有作为几何模板，调用 IsSameGerberInfo 进行统一的 robust 匹配。

    QList<GerberInfo*> preTemplatesGeom;
    QList<CGerberPadInfo*> postTemplates;

    for (QGraphicsItem* item : selectedItems)
    {
        // 类型转换：PadItem (提取前)
        PadItem* pItem = dynamic_cast<PadItem*>(item);
        if (pItem && pItem->getGerberInfo()) {
            GerberInfo* info = pItem->getGerberInfo();
            // 不再区分是否有 DCode，全部加入几何匹配流程
            preTemplatesGeom.append(info);
            continue;
        }

        // 类型转换：CGerberPadItem (提取后)
        CGerberPadItem* cpItem = dynamic_cast<CGerberPadItem*>(item);
        if (cpItem) {
            postTemplates.append(cpItem->getGerberInfo());
            continue;
        }
    }

    QString logMsg = QString("Templates: Gerber(Pre)=%0, Extracted(Post)=%1")
                         .arg(preTemplatesGeom.count()).arg(postTemplates.count());
    LOG_INFO(logMsg.toUtf8().constData());

    if (preTemplatesGeom.isEmpty() && postTemplates.isEmpty()) return;

    // 3. 遍历全场进行匹配
    bool wasBlocked = pScene->blockSignals(true); // 提升性能
    QList<QGraphicsItem*> allItems = pScene->items();
    int newCount = 0;

    for (QGraphicsItem* item : allItems)
    {
        if (item->isSelected()) continue;

        bool isMatch = false;

        // --- 匹配 PadItem (提取前) ---
        PadItem* target = dynamic_cast<PadItem*>(item);
        if (target && target->getGerberInfo()) {
            GerberInfo* tInfo = target->getGerberInfo();

            // 使用统一的几何特征匹配
            // 不再使用 DCode shortcut，确保不同 DCode 但形状相同的焊盘能被匹配
            for (GerberInfo* tpl : preTemplatesGeom) {
                if (Vision::IsSameGerberInfo(tpl, tInfo))
                {
                    isMatch = true;
                    break;
                }
            }
        }

        // 匹配 CGerberPadItem (提取后)
        if (!isMatch && !postTemplates.isEmpty()) {
            CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item);
            if (extractTarget && extractTarget->getGerberInfo()) {
                CGerberPadInfo* tInfo = extractTarget->getGerberInfo();
                for (CGerberPadInfo* tpl : postTemplates) {
                    if (Vision::IsSameCGerberPadInfo(tpl, tInfo)) {
                        isMatch = true;
                        break;
                    }
                }
            }
        }

        if (isMatch) {
            // 设置选中状态
            if (target) {
                target->SetSelectState(true);
            } else if (CGerberPadItem* extractTarget = dynamic_cast<CGerberPadItem*>(item)) {
                extractTarget->SetSelectState(true);
            }
            newCount++;
        }
    }

    pScene->blockSignals(wasBlocked);

    // 4. 刷新界面
    if (newCount > 0)
    {
        // 重新统计，确保 View 和 Model 数量一致
        QList<QGraphicsItem*> finalSelected = ui->widget_view->GetImageView()->GetSelectedItems();
        emit ui->widget_view->GetImageView()->signalSelectNum(finalSelected.count());
        ui->widget_view->GetImageView()->viewport()->update();
        LOG_INFO(QString("Matched %0 similar pads.").arg(newCount).toLocal8Bit());
    }
}

}```



ImageView.cpp
```C++
QList<QGraphicsItem*> ImageView::GetSelectedItems()
{
    QList<QGraphicsItem*> list;  //创建空列表来存储选中的item

    // 获取图层列表 
    QMap<QString, QGraphicsItemGroup *> groups = GetImageLayers(); //GetImageLayers()返回一个映射（QMap）,其中键（key）是图层的名称（QString），值（value）是当前图层中所选中的item。

    for (auto it = groups.begin(); it != groups.end(); ++it)  //遍历每一个图层
    {
        QGraphicsItemGroup* group = it.value();  //当前图层所有选中的item

        if (!group || !group->isVisible())   //当前图层是否有效且可见
            continue;
            
        LayerType type = group->data(Qt::UserRole + 1).value<LayerType>();  //从每一份图层中获取类型；在QT中使用data方法为对象存储自定义数据，这里使用Qt::UserRole + 1作为键来获取存储的数据，并将其转换为LayerType枚举类型（CAD，GERBER——PAD，GERBER）
        for (QGraphicsItem* item : group->childItems())   //遍历图层的每个选中的item
        {
            bool isSelected = false;

            if (type == LayerType::CAD)
            {
                CrossItem* crossItem = dynamic_cast<CrossItem*>(item); //如果选中的item是CAD，就将图形item转换为CrossItem，这里使用的是dynamic_cast（安全地向下转型），它是C++中的一个类型转换操作符，主要用于多态类型之间的转换，将基类指针或引用转换为派生类指针或引用，这是dynamic_cast最常见的用途。
                if (crossItem && crossItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER_PAD)
            {
                CGerberPadItem* padItem = dynamic_cast<CGerberPadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }
            else if (type == LayerType::GERBER)
            {
                PadItem* padItem = dynamic_cast<PadItem*>(item);
                if (padItem && padItem->GetSelectState()) {
                    isSelected = true;
                }
            }

            if (isSelected)
            {
                list.append(item);   //如果图形被选中，就添加到列表
            }
        }
    }
    return list;
}
```